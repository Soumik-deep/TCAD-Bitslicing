# -*- coding: utf-8 -*-
"""Copy of Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1skJJDnkbtFBiGlygfK2JWp7WJ7627H1O
"""

!nvidia-smi

from google.colab import drive
drive.mount('/content/gdrive')

!ls
!nvidia-smi
!pwd
import os
!ls
path2dir="/content/gdrive/MyDrive/"
os.chdir(path2dir)
!pwd

!pip install nufhe[pycuda]

import random
import nufhe
import os
from numba import cuda
import subprocess 
path2dir="/content/gdrive/MyDrive/"
os.chdir(path2dir)
import TestProcess1
import tensorflow as tf
def twos_complement(n,nbits):
    return f"{n & ((1 << nbits) - 1):0{nbits}b}"   
def twos_comp_val(val,bits):
    """compute the 2's complement of int value val"""
    if (val & (1 << (bits - 1))) != 0: # if sign bit is set e.g., 8bit: 128-255
        val = val - (1 << bits)        # compute negative value
    return val 
print("Currently we are in-")
path2dir="/content/gdrive/MyDrive/"
os.chdir(path2dir)
!pwd
ctx = nufhe.Context()
secret_key, cloud_key = ctx.make_key_pair()
size = 32
bits1 = [1,0,0,1]
bits2 = [0,0,1,0]
ciphertext1 = ctx.encrypt(secret_key, bits1)
ciphertext2 = ctx.encrypt(secret_key, bits2)
print(ciphertext1)
print(ciphertext2)
#reference = [not (b1 and b2) for b1, b2 in zip(bits1, bits2)]
vm = ctx.make_virtual_machine(cloud_key)
result = vm.gate_or(ciphertext1, ciphertext2)
result_bits = ctx.decrypt(secret_key, result)

myoutput="progout.txt"
!nvidia-smi
#pid1 = subprocess.Popen(["python3","TestProcess.py",">","programresult.txt"])
result=TestProcess1.echofun()
print("Current processid is--"+str(os.getpid()))
print("Child procid is--"+str(result))
#device=ctx.get_current_device
#print(device)
#device.reset()
#assert all(result_bits == reference)
print(result_bits)
!nvidia-smi
cuda.select_device(0)
cuda.close()

!ls

!nvidia-smi
!nvidia-smi --gpu-reset
!nvidia-smi
!sudo fuser -v /dev/nvidia*

import nufhe
import numpy as np
import time
import os
import json
import pickle
!pwd
!ls
path2dir="/content/gdrive/MyDrive/"
os.chdir(path2dir)
#import subprocess
import BitslicedMult
def twos_complement(n,nbits):
    return f"{n & ((1 << nbits) - 1):0{nbits}b}"   
def twos_comp_val(bitlists, bits,n):
    arr = []
    for bit in bitlists:
        if(n==-1):
          if(bit==True):
            arr.append('1')
          else:
            arr.append('0') 
        elif(bit[n]==True):
          arr.append('1')
        else:
          arr.append('0')
    val_str = ''.join(map(str, arr))
    val=int(val_str,2)
    if (val & (1 << (bits - 1))) != 0: # if sign bit is set e.g., 8bit: 128-255
        val = val - (1 << bits)        # compute negative value
    return val

def bitsliced_adder(ca,cb):
    result_sum=[]
    carry=vm.gate_constant([False])
    for i in range(size):
        temp1=vm.gate_xor(ca[i],cb[i]) # a XOR b
        result_sum.append(vm.gate_xor(temp1,carry)) # a XOR b XOR ci
        temp2=vm.gate_and(carry,temp1) # ci and (a XOR b)
        temp3=vm.gate_and(ca[i],cb[i]) # a AND b
        carry=vm.gate_or(temp3,temp2)
        
    return result_sum

def multiply(ciX,Y,packing_length):
  temp=[]
  x=[]
  print("pack length",packing_length)
  if (packing_length>0):
    for n in range(packing_length):
      x.append(np.flipud(np.array(list(twos_complement(0,size))).astype(bool)))
    for i in range(size):
      temp1=[y[i] for y in x]
      cx = vm.gate_constant(temp1)
      temp.append(cx)
  for x in range(abs(int(Y))):
    temp=bitsliced_adder(ciX,temp)
  if Y<0:
    temp=enc_twos_complement(temp,packing_length)
  return temp

def enc_twos_complement(ciX,packing_length):
  x=[]
  one_c=[]
  ciX_inv=[]
  for j in range(len(ciX)):
    ciX_inv.append(vm.gate_not(ciX[j]))
  if (packing_length>0):
    for n in range(packing_length):
      x.append(np.flipud(np.array(list(twos_complement(1,size))).astype(bool)))
    for i in range(size):
      temp1=[y[i] for y in x]
      cx = vm.gate_constant(temp1)
      one_c.append(cx)
  return bitsliced_adder(ciX_inv,one_c)

def enc_scalar_add(ciX,ciY):
  result=[]
  for i in range(len(ciX)):
    result.append(bitsliced_adder(ciX[i],ciY[i]))

  return result

def scalarEncrypt(X):
    result_scalar=[]
    for i in range (len(X)):
      px=np.flipud(np.array(list(twos_complement(int(X[i]),size))).astype(bool))
      ciX = ctx.encrypt(secret_key, px)
      result_scalar.append(ciX)
    
    return result_scalar
def scalarDecrypt(X):
    result_scalar=[]
    for i in range (len(X)):
      y = ctx.decrypt(secret_key,X[i])
      result_scalar.append(twos_comp_val(np.flipud(np.array(y)),size,-1))

    return result_scalar

def bit_encrypt(n):
  ciphertext=[]
  x=np.flipud(np.array(list(twos_complement(int(n),size))).astype(bool))
  for i in range(size):
    cx = ctx.encrypt(secret_key, [x[i]])
    ciphertext.append(cx)

  return ciphertext

def scalar_bit_encrypt(X):
  result=[]
  for i in range(len(X)):
    result.append(bit_encrypt(X[i]))

  return result

def bitsliced_encrypt(N):
  ciphertext=[]
  x=[]
  for n in N:
    x.append(np.flipud(np.array(list(twos_complement(int(n),size))).astype(bool)))
 
  for i in range(size):
    temp=[y[i] for y in x]
    cix = ctx.encrypt(secret_key, temp)
    ciphertext.append(cix)

  return ciphertext

def encrypted_relu(N):
  sign=vm.gate_constant([False])
  enc_zer0=vm.gate_constant(np.array(list(twos_complement(0,size))).astype(bool))
  result=[]
  for n in N:
    sign.a[0]=n.a[-1]
    sign.b[0]=n.b[-1]
    result.append(vm.gate_mux(sign,enc_zer0,n))
  
  return result

def unpack_ciphertext(N,pack_length):
  ciphertext=[]
  x=np.array(list(twos_complement(0,size))).astype(bool) ## initialize to zero
  for i in range(pack_length):
      cx = vm.gate_constant(x)
      ciphertext.append(cx)
 
  for n in range(pack_length):
    for i in range(size):
      ciphertext[n].a[i] = N[i].a[n]
      ciphertext[n].b[i] = N[i].b[n]

  return ciphertext

def repack_ciphertext(N):
  ciphertext=[]
  x=[]
  ## initialize to zero
  for n in range(len(N)):
      x.append(np.flipud(np.array(list(twos_complement(0,size))).astype(bool)))
  for i in range(size):
      temp1=[y[i] for y in x]
      cx = vm.gate_constant(temp1)
      ciphertext.append(cx)
 
  for i in range(size):
    for n in range(len(N)):
      ciphertext[i].a[n] = N[n].a[i]
      ciphertext[i].b[n] = N[n].b[i]

  return ciphertext

def bit_decrypt(ciX):
  plaintext=[]
  ciphertextlength = len(ciX)
  for i in range(ciphertextlength):
    x = ctx.decrypt(secret_key, ciX[i])
    plaintext.append(x)

  return np.flipud(np.array(plaintext))

def scalar_bit_decrypt(X):
  result=[]
  for i in range(len(X)):
    result.append(bit_decrypt(X[i]))

  return result

def create_weight_dict(deci_y,rownum,colnum):
  weight={}
  zero=np.array(list(twos_complement(0,size))).astype(bool)
  result_matrix=np.empty((rownum,colnum), dtype=object)
  for i in range(rownum):
    for j in range(colnum):
      w=int(deci_y[i][j])
      if w in weight:
        weight[w].append(i*colnum+j)
      else:
        weight[w]=[i*colnum+j]
      result_matrix[i][j]=vm.gate_constant(zero) #initialize to zero
  return weight,result_matrix
      
      

def denseLayer(layer,input,weight_matrix,bias):
  ## Layer encrypted task
  deci_y=weight_matrix
  rownum=len(weight_matrix)
  colnum=len(weight_matrix[0])

  ## create the weight dictionary
  begin = time.time()
  weight,result_matrix = create_weight_dict(deci_y,rownum,colnum)
  end = time.time()
  print(f"Total runtime to create weight dictionary is: {int(end - begin)} second")
  print("Number of distinct Weight:",len(weight.keys()))
  ## Repack and multiply
  begin = time.time()
  result_scalar=[]
  i=0
  for w in weight:
    i=i+1
    print("Currently at Iteration #="+str(i))
    cx=[]
    pos_arr=[]
    for k in weight[w]:
      pos = (int)((k-k%colnum)/colnum)
      if(pos not in pos_arr):
        pos_arr.append(pos)
        cx.append(input[pos]) 
    if(layer.lower() !='first'):
        ciX=repack_ciphertext(cx)
    else:
        ciX=bitsliced_encrypt(cx)
    
    ##Check before forking
    !nvidia-smi
    #result_scalar.append(BitslicedMult.multiply(np,vm,ciX,w,len(cx)))
    #argsfile=path2dir+str("arguments.txt")
    #with open(argsfile,'w') as farg:
     # farg.write(cloud_key)
     # farg.write(ciX)
     # farg.write(w)
      #farg.write(len(cx))
    #farg.close()
    #arguments= '{"vmkey": cloud_key, "Xcipher": ciX, "Ycipher":Y,"Packing_width":len(cx)}'
    #arg_dict = json.loads(arguments)
    #arg_dict={}
    #arg_dict['vmkey']=cloud_key
    #arg_dict['Xcipher']=ciX
    #arg_dict['Ycipher']=w
    #arg_dict['Packing_width']=len(cx)
    #argsname="DictFile.pkl"
    #argsfile = open("DictFile.pkl","wb")
    #pickle.dump(arg_dict, argsfile)
    #argsfile.close()

    #result_scalar.append(subprocess.Popen(['python3 BitslicedMult1.py',argsname]))
    #result_scalar.append(BitslicedMult1.__init__(arg_dict))
    producttuple=[]
    producttuple=BitslicedMult.multiply(vm,ciX,w,len(cx))
    procid=producttuple.pop()
    print("BirslicedMult process-id is--"+str(procid))
    result_scalar.append(producttuple)
    !nvidia-smi

    print("Currently at Iteration #="+str(i))
    if i>10:
      os.exit()

  end = time.time()
  print(f"Total runtime of the repack and multiply program is {int(end - begin)} second") 
  ## Unpack and rearrange
  begin = time.time() 
  rx=0
  for w in weight:
    pos_arr=[]
    for i in range(len(weight[w])):
      for j in range(size):
        k=weight[w][i]
        col=k%colnum
        row=(int)((k-col)/colnum)
        if(row not in pos_arr):
          pos_arr.append(row)
        pack_pos=pos_arr.index(row)
        result_matrix[row][col].a[j]=result_scalar[rx][j].a[pack_pos]
        result_matrix[row][col].b[j]=result_scalar[rx][j].b[pack_pos]
    rx+=1
  end = time.time()
  print(f"Total runtime of the unpack and rearrange program is {int(end - begin)} second") 
  ## Repack and add
  begin = time.time()
  adder_result = bias ## weight0 as bias
  for i in range(rownum):
    ciX = repack_ciphertext(result_matrix[i])
    adder_result= bitsliced_adder(ciX,adder_result)
  end = time.time()
  print(f"Total runtime of the repack and add program is {int(end - begin)} second") 

  ## Unpack scalar
  begin = time.time()
  layer_output=unpack_ciphertext(adder_result,colnum)
  end = time.time()
  print(f"Total runtime of the unpack program is {int(end - begin)} second") 
  ## encryoted relu
  if(layer.lower() !='last'):
    layer_output=encrypted_relu(layer_output)

  return layer_output

## context creation
ctx = nufhe.Context()
secret_key, cloud_key = ctx.make_key_pair()
print("My cloudkey is--")
print(cloud_key)
vm = ctx.make_virtual_machine(cloud_key)
#set bit size for operation
size = 32
## MNIST data testing
begin0 = time.time()
test_samples = np.around(np.load("test_samples.npy") * 255)
test_labels = np.load("test_labels.npy")
x_adv = np.load(f"x_adv.npy")
num_params = len(os.listdir("params"))
params = []
for i in range(num_params):
	params.append(np.loadtxt(f"params/p{i}.txt", delimiter=","))
#enc_sample = scalarEncrypt(test_samples[0])
enc_params_1 = bitsliced_encrypt(params[1])
begin = time.time()
print("######## Layer 0 operation starting............")
layer_0_output = denseLayer('first',test_samples[0],params[0],enc_params_1)
#layer_0_output = bitsliced_adder(bitsliced_encrypt(np.matmul(test_samples[0], params[0])),enc_params_1)
#layer_0_output=unpack_ciphertext(layer_0_output,len(params[1])) ## unpack to result ciphertexts
#layer_0_output = encrypted_relu(layer_0_output)
end = time.time()
print(f"Total runtime of the first layer is {int(end - begin)} second")
print("Layer 0 output:",scalarDecrypt(layer_0_output))
enc_params_3 = bitsliced_encrypt(params[3])
begin = time.time()
print("######## Layer 1 operation starting............")
layer_1_output = denseLayer('second',layer_0_output,params[2],enc_params_3)
end = time.time()
print(f"Total runtime of the layer 1 is {int(end - begin)} second")
print("Layer 1 output:",scalarDecrypt(layer_1_output))
enc_params_5 = bitsliced_encrypt(params[5])
begin = time.time()
print("######## Layer 2 operation starting............")
layer_2_output = denseLayer('third',layer_1_output,params[4],enc_params_5)
end = time.time()
print(f"Total runtime of the layer 2 is {int(end - begin)} second")
print("Layer 2 output:",scalarDecrypt(layer_2_output))
enc_params_7 = bitsliced_encrypt(params[7])
begin = time.time()
print("######## Layer 3 operation starting............")
layer_3_output = denseLayer('last',layer_2_output,params[6],enc_params_7)
end = time.time()
print(f"Total runtime of the last layer is {int(end - begin)} second")
print("Layer 3 output:",scalarDecrypt(layer_3_output))
result= scalarDecrypt(layer_3_output)
end0 = time.time()
print("Last layer output:",result)
print("Predicted digit",np.argmax(result))
print(f"Total runtime of the program is {int(end0 - begin0)} second")
