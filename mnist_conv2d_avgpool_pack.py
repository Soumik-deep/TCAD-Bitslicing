# -*- coding: utf-8 -*-
"""MNIST_Conv2d_AvgPool_Temp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QRGcY5F9ab4sF6juMtUyMkENTWvYW-UG
"""

#!nvidia-smi

# -*- coding: utf-8 -*-
"""MNIST_Conv2d+MaxPool.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AAhEOu6R7JoQ_FIPNDRzTldzAZRwRnu8
"""

# -*- coding: utf-8 -*-
"""MNIST_Conv2d+MaxPool.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AAhEOu6R7JoQ_FIPNDRzTldzAZRwRnu8
"""

#!cat /proc/cpuinfo

#from google.colab import drive
#drive.mount('/content/gdrive')

#!pip install nufhe[pycuda]

# -*- coding: utf-8 -*-
"""MNIST-EncryptedConv2D.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kuD4VsWXNJbLzbhVKcr0C0i_GHfk1D-3
"""

##nvidia-smi

#from google.colab import drive
#drive.mount('/content/gdrive')

#!pip install nufhe[pycuda]

# -*- coding: utf-8 -*-
"""Copy of Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1skJJDnkbtFBiGlygfK2JWp7WJ7627H1O
"""


import nufhe
import numpy as np
import time
import os
import json
import pickle
import random
#import tracemalloc
#import memory_profiler
import numba
import functools
from functools import lru_cache
from numba import jit
#from memory_profiler import profile
#from cachetools import cached, TTLCache
#!pwd
#!ls
#path2dir="/content/gdrive/MyDrive/Colab Notebooks"
#path2dir="/content/gdrive/MyDrive/"
#path2dir="/home/user/soumik/workspace/"
#os.chdir(path2dir)
import subprocess
import BitslicedMult
import os
os.environ['PYOPENCL_NO_CACHE'] = '1'

#repack_time=0
#packing_time=0
def twos_complement(n,nbits):
    return f"{n & ((1 << nbits) - 1):0{nbits}b}"   
def twos_comp_val(bitlists, bits,n):
    arr = []
    for bit in bitlists:
        if(n==-1):
          if(bit==True):
            arr.append('1')
          else:
            arr.append('0') 
        elif(bit[n]==True):
          arr.append('1')
        else:
          arr.append('0')
    val_str = ''.join(map(str, arr))
    val=int(val_str,2)
    if (val & (1 << (bits - 1))) != 0: # if sign bit is set e.g., 8bit: 128-255
        val = val - (1 << bits)        # compute negative value
    return val

def bitsliced_adder(ca,cb):
    result_sum=[]
    carry=vm.gate_constant([False])
    for i in range(size):
        temp1=vm.gate_xor(ca[i],cb[i]) # a XOR b
        result_sum.append(vm.gate_xor(temp1,carry)) # a XOR b XOR ci
        temp2=vm.gate_and(carry,temp1) # ci and (a XOR b)
        temp3=vm.gate_and(ca[i],cb[i]) # a AND b
        carry=vm.gate_or(temp3,temp2)
        
    return result_sum

def multiply(ciX,Y,packing_length):
  temp=[]
  x=[]
  #print("pack length",packing_length)
  if (packing_length>0):
    for n in range(packing_length):
      x.append(np.flipud(np.array(list(twos_complement(0,size))).astype(bool)))
    for i in range(size):
      temp1=[y[i] for y in x]
      cx = vm.gate_constant(temp1)
      temp.append(cx)
  for x in range(abs(int(Y))):
    temp=bitsliced_adder(ciX,temp)
  if Y<0:
    temp=enc_twos_complement(temp,packing_length)
  return temp

def convAdd(ciX,Y,packing_length):
  temp=[]
  x=[]
  #print("pack length",packing_length)
  if (packing_length>0):
    for n in range(packing_length):
      x.append(np.flipud(np.array(list(twos_complement(0,size))).astype(bool)))
    for i in range(size):
      temp1=[y[i] for y in x]
      cx = vm.gate_constant(temp1)
      temp.append(cx)
  for x in range(abs(int(Y))):
    temp=bitsliced_adder(ciX,temp)
  if Y<0:
    temp=enc_twos_complement(temp,packing_length)
  return temp


def enc_twos_complement(ciX,packing_length):
  x=[]
  one_c=[]
  ciX_inv=[]
  for j in range(len(ciX)):
    ciX_inv.append(vm.gate_not(ciX[j]))
  if (packing_length>0):
    for n in range(packing_length):
      x.append(np.flipud(np.array(list(twos_complement(1,size))).astype(bool)))
    for i in range(size):
      temp1=[y[i] for y in x]
      cx = vm.gate_constant(temp1)
      one_c.append(cx)
  return bitsliced_adder(ciX_inv,one_c)

def enc_scalar_add(ciX,ciY):
  result=[]
  for i in range(len(ciX)):
    result.append(bitsliced_adder(ciX[i],ciY[i]))

  return result

def scalarEncrypt(X):
    result_scalar=[]
    for i in range (len(X)):
      px=np.flipud(np.array(list(twos_complement(int(X[i]),size))).astype(bool))
      ciX = ctx.encrypt(secret_key, px)
      result_scalar.append(ciX)

    #print("Dimension of ciphertrxt is="+str(len(result_scalar)))
    
    return result_scalar

def scalarDecrypt(X):
    result_scalar=[]
    for i in range (len(X)):
      y = ctx.decrypt(secret_key,X[i])
      result_scalar.append(twos_comp_val(np.flipud(np.array(y)),size,-1))

    return result_scalar

def bit_encrypt(n):
  ciphertext=[]
  x=np.flipud(np.array(list(twos_complement(int(n),size))).astype(bool))
  for i in range(size):
    cx = ctx.encrypt(secret_key, [x[i]])
    ciphertext.append(cx)

  return ciphertext

def scalar_bit_encrypt(X):
  result=[]
  for i in range(len(X)):
    result.append(bit_encrypt(X[i]))

  return result

def bitsliced_encrypt(N):
  ciphertext=[]
  x=[]
  for n in N:
    x.append(np.flipud(np.array(list(twos_complement(int(n),size))).astype(bool)))
 
  for i in range(size):
    temp=[y[i] for y in x]
    cix = ctx.encrypt(secret_key, temp)
    ciphertext.append(cix)

  return ciphertext

def encrypted_relu(N):
  sign=vm.gate_constant([False])
  enc_zer0=vm.gate_constant(np.array(list(twos_complement(0,size))).astype(bool))
  result=[]
  for n in N:
    sign.a[0]=n.a[-1]
    sign.b[0]=n.b[-1]
    result.append(vm.gate_mux(sign,enc_zer0,n))
  
  return result

#@jit(nopython=True,parallel=True)
def paralleltranspose1(ciphertext,N):

  for n in range(pack_length):
    for i in range(size):
      ciphertext[n].a[i] = N[i].a[n]
      ciphertext[n].b[i] = N[i].b[n]
      
  return ciphertext


def unpack_ciphertext(N,pack_length):
  ciphertext=[]
  x=np.array(list(twos_complement(0,size))).astype(bool) ## initialize to zero
  for i in range(pack_length):
      cx = vm.gate_constant(x)
      ciphertext.append(cx)
  
  
  #unpacked_ciphertext=paralleltranspose1(ciphertext,N)
  for n in range(pack_length):
    for i in range(size):
      ciphertext[n].a[i] = N[i].a[n]
      ciphertext[n].b[i] = N[i].b[n]

  return ciphertext

#@jit(nopython=True,parallel=True)
def paralleltranspose2(ciphertext,N):

  print("Soumik...we are printing the ciphertexts")
  beginrepack=time.time()
  #print("Repacking Start Time="+str(time.time()))
  for i in range(size):
    for n in range(len(N)):
      #print(ciphertext[i].a[n])
      #print(N[n].a[i])
      ciphertext[i].a[n] = N[n].a[i]
      ciphertext[i].b[n] = N[n].b[i]
  #print("Repacking End Time="+str(time.time()))
  endrepack=time.time()
  print(f"Total runtime of individual ciphertext repacking operation is {int(endrepack - beginrepack)} second")
  return ciphertext


def repack_ciphertext(N):
  ciphertext=[]
  x=[]
  ## initialize to zero
  for n in range(len(N)):
      x.append(np.flipud(np.array(list(twos_complement(0,size))).astype(bool)))
  for i in range(size):
      temp1=[y[i] for y in x]
      cx = vm.gate_constant(temp1)
      ciphertext.append(cx)
 
  #for i in range(size):
   # for n in range(len(N)):
    #  ciphertext[i].a[n] = N[n].a[i]
     # ciphertext[i].b[n] = N[n].b[i]

  repacked_ciphertext=paralleltranspose2(ciphertext,N)
  return repacked_ciphertext



def bit_decrypt(ciX):
  plaintext=[]
  ciphertextlength = len(ciX)
  for i in range(ciphertextlength):
    x = ctx.decrypt(secret_key, ciX[i])
    plaintext.append(x)

  return np.flipud(np.array(plaintext))

def scalar_bit_decrypt(X):
  result=[]
  for i in range(len(X)):
    result.append(bit_decrypt(X[i]))

  return result
  
  
def create_weight_dict_dense(deci_y,rownum,colnum):
  weight={}
  print("The rownum and colnum are "+str(rownum)+"and "+str(colnum))
  zero=np.array(list(twos_complement(0,size))).astype(bool)
  result_matrix=np.empty((rownum,colnum), dtype=object)
  for i in range(rownum):
    for j in range(colnum):
      w=int(deci_y[i][j])
      if w in weight:
        weight[w].append(i*colnum+j)
      else:
        weight[w]=[i*colnum+j]
      result_matrix[i][j]=vm.gate_constant(zero) #initialize to zero
  return weight,result_matrix
  
  
  
  
def create_weight_dict(deci_y,rownum,colnum):
  weight={}
  zero=np.array(list(twos_complement(0,size))).astype(bool)
  result_matrix=np.empty((26,rownum,colnum), dtype=object)
  
  for i in range(rownum):
    for j in range(colnum):
      w=int(deci_y[i][j])
      if w in weight:
        weight[w].append(i*colnum+j)
      else:
        weight[w]=[i*colnum+j]

      for row in range(26):
        result_matrix[row][i][j]=vm.gate_constant(zero) #initialize to zero

  return weight,result_matrix
      

#fp1=open('INT8CNNDense_memory_profiler.log','a+')     
#@profile(stream=fp1)
def denseLayer(layer,input,weight_matrix,bias):
  ## Layer encrypted task
  #print("Dense Layer Memory Profiling")
  deci_y=weight_matrix
  rownum=len(weight_matrix)
  colnum=len(weight_matrix[0])

  #print("No of rows in weight matrix="+str(rownum))
  #print("No of columns in wgt matrix="+str(rownum))
  ## create the weight dictionary
  begin = time.time()
  weight,result_matrix = create_weight_dict_dense(deci_y,rownum,colnum)
  end = time.time()
  #print(f"Total runtime to create weight dictionary is: {int(end - begin)} second")
  #print("Number of distinct Weight:",len(weight.keys()))
  ## Repack and multiply
  begin = time.time()
  result_scalar=[]
  i=0
  for w in weight:
    i=i+1
    print("Currently at Denselayer Iteration #="+str(i))
    cx=[]
    pos_arr=[]
    for k in weight[w]:
      #print("k-val is"+str(k))
      pos = (int)((k-k%colnum)/colnum)
      if(pos not in pos_arr):
        pos_arr.append(pos)
       # print("The pos value="+str(pos))
        cx.append(input[pos]) 
    if(layer.lower() !='first'):
        ciX=repack_ciphertext(cx)
    else:
        ciX=bitsliced_encrypt(cx)
    
    myCmd = os.popen('nvidia-smi').read()
    #print(myCmd)
    memstats="MNISTDenseMemstats.txt"
    with open(memstats,"a+") as fmem:
    	fmem.write(str(myCmd)) 
    ##Check before forking
    #!nvidia-smi
    #result_scalar.append(BitslicedMult.multiply(np,vm,ciX,w,len(cx)))
    #argsfile=path2dir+str("arguments.txt")
    #with open(argsfile,'w') as farg:
     # farg.write(cloud_key)
     # farg.write(ciX)
     # farg.write(w)
      #farg.write(len(cx))
    #farg.close()
    #arguments= '{"vmkey": cloud_key, "Xcipher": ciX, "Ycipher":Y,"Packing_width":len(cx)}'
    #arg_dict = json.loads(arguments)
    #arg_dict={}
    #arg_dict['vmkey']=cloud_key
    #arg_dict['Xcipher']=ciX
    #arg_dict['Ycipher']=w
    #arg_dict['Packing_width']=len(cx)
    #argsname="DictFile.pkl"
    #argsfile = open("DictFile.pkl","wb")
    #pickle.dump(arg_dict, argsfile)
    #argsfile.close()

    #result_scalar.append(subprocess.Popen(['python3 BitslicedMult1.py',argsname]))
    #result_scalar.append(BitslicedMult1.__init__(arg_dict))
    producttuple=[]
    producttuple=multiply(ciX,w,len(cx))
    #procid=producttuple.pop()                ##This popping is done only when Bitslicedmult.py is invoked...pid popping not reqd for native fun##
    #print("BirslicedMult process-id is--"+str(procid))
    result_scalar.append(producttuple)
    ##!nvidia-smi

    #print("Currently at Iteration #="+str(i))
    #if i>10:
     # os.exit()

  end = time.time()
  #print(f"Total runtime of the repack and multiply program is {int(end - begin)} second") 
  ## Unpack and rearrange
  begin = time.time() 
  rx=0
  for w in weight:
    pos_arr=[]
    for i in range(len(weight[w])):
      for j in range(size):
        k=weight[w][i]
        col=k%colnum
        row=(int)((k-col)/colnum)
        if(row not in pos_arr):
          pos_arr.append(row)
        pack_pos=pos_arr.index(row)
        result_matrix[row][col].a[j]=result_scalar[rx][j].a[pack_pos]
        result_matrix[row][col].b[j]=result_scalar[rx][j].b[pack_pos]
    rx+=1
  end = time.time()
  #print(f"Total runtime of the unpack and rearrange program is {int(end - begin)} second") 
  ## Repack and add
  begin = time.time()
  adder_result = bias ## weight0 as bias
  for i in range(rownum):
    ciX = repack_ciphertext(result_matrix[i])
    adder_result= bitsliced_adder(ciX,adder_result)
  end = time.time()
  #print(f"Total runtime of the repack and add program is {int(end - begin)} second") 

  ## Unpack scalar
  begin = time.time()
  layer_output=unpack_ciphertext(adder_result,colnum)
  end = time.time()
  #print(f"Total runtime of the unpack program is {int(end - begin)} second") 
  ## encryoted relu
  if(layer.lower() !='last'):
    layer_output=encrypted_relu(layer_output)

  return layer_output


def masklsb(ca,cb):
  result_sum=[]
  size=32 
  for i in range(size):
        temp1=vm.gate_and(ca[i],cb[i]) # a XOR b
        result_sum.append(temp1) # a XOR b XOR ci
        #temp2=vm.gate_and(carry,temp1) # ci and (a XOR b)
        #temp3=vm.gate_and(ca[i],cb[i]) # a AND b
        #carry=vm.gate_or(temp3,temp2)
        
  return result_sum

 
def aggregate(X):

  X1=[]
  X2=[]
  X3=[]
  #print("Length of X input is"+str(len(X)))
  X11=[]
  X22=[]
  sum1=[]
  sum2=[]

  enczero=bit_encrypt(0)  

  X1.append(enczero)
  X1.append(enczero)
  X1.append(X[2])
  #X1=X
  #X2=X
  #X3=X

  X2.append(enczero)
  X2.append(enczero)
  X2.append(X[1])
  #temp2=X2[2]
  #X2[2]=X2[1]
  #X2[1]=temp2

  ##Swapping LSB with the MSB Operand##

  #temp3=X3[2]
  #X3[2]=X3[0]
  #X3[0]=temp3

  X3.append(enczero)
  X3.append(enczero)
  X3.append(X[0])

  #print("Size of individual subarrays="+str(len(X2)))
  allzeros=[]
  allzeros.append(0)
  allzeros.append(0)
  allzeros.append(1)
  #print("Contents and length of all zero array="+str(len(allzeros))+str(allzeros))
  ciX=bitsliced_encrypt(allzeros)
  #print("Contents and length of all zero array="+str(len(ciX))+str(ciX))
  X11=repack_ciphertext(X)
  temp0=X[2]
  X[2]=X[1]
  X[1]=temp0
  X22=repack_ciphertext(X)
  temp0=X[2]
  X[2]=X[0]
  X[0]=temp0
  X33=repack_ciphertext(X)
  #op1=masklsb(X11,ciX)
  #op2=masklsb(X22,ciX)
  #op3=masklsb(X33,ciX)

  sum1=bitsliced_adder(X11,X22)
  sum2=bitsliced_adder(sum1,X33)
  #sum2[0]=enczero
  #sum2[1]=enczero
  return sum2


def wgtaccumulator(weight,result_matrix,result_scalar,colnum):

  #size=16
  size=12
  begin = time.time() 
  rx=0
  #print("Size of result_scalar=")
  print(len(result_scalar[0]))
  for w in weight:
    pos_arr=[]
    for i in range(len(weight[w])):
      #print("Size value="+str(size))
      for j in range(size):
        k=weight[w][i]
        col=k%colnum
        row=(int)((k-col)/colnum)
        if(row not in pos_arr):
          pos_arr.append(row)
        pack_pos=pos_arr.index(row)
        #print("Debug variables")
        #print(row)
        #print(col)
        #print(rx)
        #print(pack_pos)
        #print(j)
        result_matrix[row][col].a[j]=result_scalar[rx][j].a[pack_pos]
        result_matrix[row][col].b[j]=result_scalar[rx][j].b[pack_pos]
        #print("Postmortem report:"+str(result_matrix[row][col])+"   "+str(result_scalar[rx][j].a[pack_pos]))    
    rx+=1
  end = time.time()
  print(f"Total runtime of the unpack and rearrange/wgtaccumulator program is {int(end - begin)} second") 
  return result_matrix




def convMulAcc(layer,input,kern_matrix,kern_dim,bias,xshft,yshft):
  ## Layer encrypted task
  deci_y=kern_matrix
  #rownum=kern_dim*kern_dim
  rownum=kern_dim
  colnum=kern_dim
  inpdim=28
  #rownum=len(weight_matrix)
  #colnum=len(weight_matrix[0])
  print("wgt matrix="+str(kern_matrix))
  print("Weight matrix[0"+str(kern_matrix[0]))
  print(str(rownum)+"Rownum is this")
  print(str(colnum)+"Colnumis this")
  ## create the weight dictionary
  begin = time.time()
  weight,result_matrix = create_weight_dict(deci_y,rownum,colnum)
  end = time.time()
  print(f"Total runtime to create weight dictionary is: {int(end - begin)} second")
  print("Number of distinct Weight:",len(weight.keys()))
  ## Repack and multiply
  begin = time.time()
  result_scalar=[]
  i=0
  global packing_time
  numconv=6
  #numconv=inpdim-kern_dim+1
  print("COnv is a "+str(numconv)+"X"+str(numconv)+" matrix")
  #input1 = np.minimum(input, 3)
  #input[0][0] = 3.0
  #input[0][1]=3.0
  #input[0][2]=3.0
  #input[1][0]=3.0
  #input[1][1]=3.0
  #input[1][2]=3.0

  #input[np.iszero(x)] = 3.0
  np.put(input, [0,1,2,28,29,30,56,57,58,59], [3,3,3,3,3,3,3,3,3,3])
  repack_time=0
  print(input)
  for w in weight:
    i=i+1
    print("Currently at Iteration #="+str(i))
    cx=[]
    pos_arr=[]
    k=weight[w][0]
    repackstart=0
    repack_time=0
    #pos = (int)((k-k%colnum)/colnum)
    inpi=(int)(k/colnum)
    inpj=k%colnum
    #pos=(inpi*inpdim)+inpj
    pos=((inpi+yshft)*inpdim)+(inpj+xshft)
    for pix in range(numconv):
      #k=weight[w]
      #pos = (int)((k-k%colnum)/colnum)
      #inpi=(int)(k/colnum)
      #inpj=k%colnum
      #pos=(inpi*inpdim)+inpj
      #pos=((inpi+yshft)*inpdim)+(inpj+xshft)
      if(pos not in pos_arr):
        pos_arr.append(pos)
        cx.append(input[pos]) 
      pos=pos+1

    if(layer.lower() =='conv'):
         ciX=repack_ciphertext(cx)
    else:
    #	repackstart=time.time()
        ciX=bitsliced_encrypt(cx)
        repackend=time.time()
        repack_time=repack_time+int(repackend-repackstart)
        packing_time=repack_time+packing_time
        print("Repacking/Bitsliced encryption takes-"+str(repack_time)+" secs")
    print("repacked cipheertext="+str(ciX))
    print("cx array ="+str(cx))    
    ##Check before forking




   ## !nvidia-smi
    #result_scalar.append(BitslicedMult.multiply(np,vm,ciX,w,len(cx)))
    #argsfile=path2dir+str("arguments.txt")
    #with open(argsfile,'w') as farg:
     # farg.write(cloud_key)
     # farg.write(ciX)
     # farg.write(w)
      #farg.write(len(cx))
    #farg.close()
    #arguments= '{"vmkey": cloud_key, "Xcipher": ciX, "Ycipher":Y,"Packing_width":len(cx)}'
    #arg_dict = json.loads(arguments)
    #arg_dict={}
    #arg_dict['vmkey']=cloud_key
    #arg_dict['Xcipher']=ciX
    #arg_dict['Ycipher']=w
    #arg_dict['Packing_width']=len(cx)
    #argsname="DictFile.pkl"
    #argsfile = open("DictFile.pkl","wb")
    #pickle.dump(arg_dict, argsfile)
    #argsfile.close()

    #result_scalar.append(subprocess.Popen(['python3 BitslicedMult1.py',argsname]))
    #result_scalar.append(BitslicedMult1.__init__(arg_dict))
    mult_start=time.time()
    producttuple=[]
    producttuple=multiply(ciX,w,len(cx))
    mult_end=time.time()
    print("ONly Multiplication takes ---"+str(int(mult_end-mult_start))+"secs")
    #procid=producttuple.pop()
    #print("BirslicedMult process-id is--"+str(procid))
    result_scalar.append(producttuple)

    ##!nvidia-smi

    print("Currently at Iteration #="+str(i))
    ##if i>10:
     ## os.exit()

  end = time.time()
  print(f"Total runtime of the repack and multiply program is {int(end - begin)} second") 
  ## Unpack and rearrange
  begin = time.time() 
  rx=0
  for w in weight:
    pos_arr=[]
    k=weight[w][0]
    matnum=0
    inpi=(int)(k/colnum)
    inpj=k%colnum
    #col=k%colnum
    #row=(int)((k-col)/colnum)
    row=inpi
    col=inpj
    for i in range(numconv):
      #k=weight[w][0]
      #inpi=(int)(k/colnum)
      #inpj=k%colnum
      #col=k%colnum
      #row=(int)((k-col)/colnum)
      #row=inpi
      #col=inpj
      if(row not in pos_arr):
        pos_arr.append(row)
      pack_pos=pos_arr.index(row)
      back_pos=i
      for j in range(size):
        #k=weight[w][i]
        #col=k%colnum
        #row=(int)((k-col)/colnum)
        #if(row not in pos_arr):
        #  pos_arr.append(row)
        #pack_pos=pos_arr.index(row)
        result_matrix[matnum][row][col].a[j]=result_scalar[rx][j].a[back_pos]
        result_matrix[matnum][row][col].b[j]=result_scalar[rx][j].b[back_pos]
        #print("Postmortem report:"+str(result_matrix[row][col])+"   "+str(result_scalar[rx][j].a[pack_pos]))  
      matnum+=1
      k+=1  
    rx+=1
  end = time.time()
  print(f"Total runtime of the unpack and rearrange program is {int(end - begin)} second") 
  ## Repack and add
  begin = time.time()
  #adder_result = bias ## weight0 as bias
  #adder_result=0.0

  cx=[]
  for i in range(rownum):
      for j in range(colnum):
          cx.append(result_matrix[0][i][j])
  #SSSconvcphers=repack_ciphertext(cx)
  #ciX=repack_ciphertext(cx)   
  
  adder_result=repack_ciphertext(result_matrix[0][0])
  for i in range(1,rownum):
    ciX = repack_ciphertext(result_matrix[0][i])
    adder_result= bitsliced_adder(ciX,adder_result)
  
  #adder_result = bitsliced_encrypt(0) ## weight0 as bias
  
  print(f"Total runtime of the repack and add program is {int(end - begin)} second") 
  print("Outputing the conv output")
  #for k in range(size):
   # print(adder_result.a[k])

  #SSSadder_result=convAdd(convcphers,0,rownum*colnum)
  ## Unpack scalar
  begin = time.time()
  #SSSlayer_output=unpack_ciphertext(adder_result,colnum*rownum)
  end = time.time()
  
  #for i in range(rownum):
  #  for j in range(colnum):
  #    cx.append(result_matrix[i][j])
  #convcphers=repack_ciphertext(cx)
  #end = time.time()
  print(f"Total runtime of the repack and add program is {int(end - begin)} second") 
  print("Outputing the conv output")
  #for k in range(size):
   # print(adder_result.a[k])

  #conv_result=cx[0]
  #for ind in range(1,len(cx)):
   # conv_result=enc_scalar_add(cx[ind],conv_result)

  #adder_result=convAdd(convcphers,0,rownum*colnum)
  ## Unpack scalar
  begin = time.time()
  layer_output=unpack_ciphertext(adder_result,colnum)
  #layer_output=conv_result
  end = time.time()
  print(f"Total runtime of the unpack program is {int(end - begin)} second") 
  ## encryoted relu
  #if(layer.lower() !='last'):
   # layer_output=encrypted_relu(layer_output)
  print("The o/p of the Sample 3x3 Conv layer is")
  #convop=scalarDecrypt(layer_output)
  #Lets try enc-scalar-add here
  #conv_res=[]
  
  zerosum=aggregate(layer_output)
  zerosum1=unpack_ciphertext(zerosum,3)
  decsum=scalarDecrypt(zerosum1)
  print("Outputing the Conv OUtput through encrypted allzero method is="+str(decsum))
  print("The final o/p of fully encrypted Convolution Block="+str(decsum[2]))

  rowconv=[]
  for row in range(inpdim-kern_dim+1):
    rowconv.append(zerosum1[2])

  return rowconv
#  return zerosum1[2]


  
  
#@cached(cache = TTLCache(maxsize = 1024, ttl = 1800)) 
#@lru_cache(maxsize=256)
def convLayer(layer,kern_dim,xshft,yshft):

  ## Layer encrypted task
  print("This time testing with custom kernel")
  input=test_samples[0]
  bias=enc_params_1
  #print("ConvLayer Memory Profiling")
  #deci_y=kern_matrix
  #kern_weights=np.array([[1,2,3],[4,5,6],[7,8,9]], dtype='int32')
  kern_weights=np.array([[1,2,3],[1,2,3],[1,2,3]], dtype='int32')
  deci_y=kern_weights
  #rownum=kern_dim*kern_dim
  rownum=kern_dim
  colnum=kern_dim
  inpdim=28
  #rownum=len(weight_matrix)
  #colnum=len(weight_matrix[0])
  #print("wgt matrix="+str(deci_y))
  #print("Weight matrix[0"+str(deci_y[0]))
  #print(str(rownum)+"Rownum is this")
  #print(str(colnum)+"Colnumis this")
  ## create the weight dictionary
  begin = time.time()
  weight,result_matrix = create_weight_dict(deci_y,rownum,colnum)
  end = time.time()
  #print(f"Total runtime to create weight dictionary is: {int(end - begin)} second")
  #print("Number of distinct Weight:",len(weight.keys()))
  ## Repack and multiply
  begin = time.time()
  result_scalar=[]
  i=0
  
  #input1 = np.minimum(input, 3)
  #input[0][0] = 3.0
  #input[0][1]=3.0
  #input[0][2]=3.0
  #input[1][0]=3.0
  #input[1][1]=3.0
  #input[1][2]=3.0

  #input[np.iszero(x)] = 3.0
  np.put(input, [0,1,2,28,29,30,56,57,58,59], [3,3,3,3,3,3,3,3,3,3])
 
  repack_time=0
  #print(input)
  for w in weight:
    i=i+1
    #print("Currently at Iteration #="+str(i))
    cx=[]
    pos_arr=[]
   
    for k in weight[w]:
      #pos = (int)((k-k%colnum)/colnum)
      inpi=(int)(k/colnum)
      inpj=k%colnum
      #pos=(inpi*inpdim)+inpj
      pos=((inpi+yshft)*inpdim)+(inpj+xshft)
      if(pos not in pos_arr):
        pos_arr.append(pos)
        cx.append(input[pos]) 
    if(layer.lower() =='conv'):
        ciX=repack_ciphertext(cx)
    else:
        repackstart=time.time()
        ciX=bitsliced_encrypt(cx)
        repackend=time.time()
        repack_time=repack_time+int(repackend-repackstart)
        print("Repacking/Bitsliced encryption takes-"+str(repack_time)+" secs")
    #print("repacked cipheertext="+str(ciX))
    #print("cx array ="+str(cx))    
    ##Check before forking
    myCmd = os.popen('nvidia-smi').read()
    #print(myCmd)
    memstats="MNISTConvMemstats.txt"
    with open(memstats,"a+") as fmem:
    	fmem.write(str(myCmd)) 



   ## !nvidia-smi
    #result_scalar.append(BitslicedMult.multiply(np,vm,ciX,w,len(cx)))
    #argsfile=path2dir+str("arguments.txt")
    #with open(argsfile,'w') as farg:
     # farg.write(cloud_key)
     # farg.write(ciX)
     # farg.write(w)
      #farg.write(len(cx))
    #farg.close()
    #arguments= '{"vmkey": cloud_key, "Xcipher": ciX, "Ycipher":Y,"Packing_width":len(cx)}'
    #arg_dict = json.loads(arguments)
    #arg_dict={}
    #arg_dict['vmkey']=cloud_key
    #arg_dict['Xcipher']=ciX
    #arg_dict['Ycipher']=w
    #arg_dict['Packing_width']=len(cx)
    #argsname="DictFile.pkl"
    #argsfile = open("DictFile.pkl","wb")
    #pickle.dump(arg_dict, argsfile)
    #argsfile.close()

    #result_scalar.append(subprocess.Popen(['python3 BitslicedMult1.py',argsname]))
    #result_scalar.append(BitslicedMult1.__init__(arg_dict))
    producttuple=[]
    producttuple=multiply(ciX,w,len(cx))
    #procid=producttuple.pop()         ##This pop  is done only when foreign function BitslicedMult is called-here native func;hence omited##
    #print("BirslicedMult process-id is--"+str(procid))
    result_scalar.append(producttuple)

    ##!nvidia-smi

    #print("Currently at Iteration #="+str(i))
    ##if i>10:
     ## os.exit()

  end = time.time()
  #print(f"Total runtime of the repack and multiply program is {int(end - begin)} second") 
  
  result_matrix=wgtaccumulator(weight,result_matrix,result_scalar,colnum)
  ## Unpack and rearrange
  ###SOumik Commented code below is workinh ---has beenreplaced with compiler optimization on JIT##
  #begin = time.time() 
  #rx=0
  #for w in weight:
   # pos_arr=[]
   # for i in range(len(weight[w])):
    #  for j in range(size):
     #   k=weight[w][i]
      #  col=k%colnum
     #   row=(int)((k-col)/colnum)
      #  if(row not in pos_arr):
      #    pos_arr.append(row)
      #  pack_pos=pos_arr.index(row)
      #  result_matrix[row][col].a[j]=result_scalar[rx][j].a[pack_pos]
      #  result_matrix[row][col].b[j]=result_scalar[rx][j].b[pack_pos]
        #print("Postmortem report:"+str(result_matrix[row][col])+"   "+str(result_scalar[rx][j].a[pack_pos]))    
    #rx+=1
  #end = time.time()
  #print(f"Total runtime of the unpack and rearrange program is {int(end - begin)} second") 
  ## Repack and add
  begin = time.time()
  #adder_result = bias ## weight0 as bias
  #adder_result=0.0

  cx=[]
  for i in range(rownum):
      for j in range(colnum):
          cx.append(result_matrix[i][j])
  #SSSconvcphers=repack_ciphertext(cx)
  #ciX=repack_ciphertext(cx)   
  
  adder_result=repack_ciphertext(result_matrix[0])
  for i in range(1,rownum):
    ciX = repack_ciphertext(result_matrix[i])
    adder_result= bitsliced_adder(ciX,adder_result)
  
  #adder_result = bitsliced_encrypt(0) ## weight0 as bias
  
  #print(f"Total runtime of the repack and add program is {int(end - begin)} second") 
  #print("Outputing the conv output")
  #for k in range(size):
   # print(adder_result.a[k])

  #SSSadder_result=convAdd(convcphers,0,rownum*colnum)
  ## Unpack scalar
  begin = time.time()
  #SSSlayer_output=unpack_ciphertext(adder_result,colnum*rownum)
  end = time.time()
  
  #for i in range(rownum):
  #  for j in range(colnum):
  #    cx.append(result_matrix[i][j])
  #convcphers=repack_ciphertext(cx)
  #end = time.time()
  #print(f"Total runtime of the repack and add program is {int(end - begin)} second") 
  #print("Outputing the conv output")
  #for k in range(size):
   # print(adder_result.a[k])

  #conv_result=cx[0]
  #for ind in range(1,len(cx)):
   # conv_result=enc_scalar_add(cx[ind],conv_result)

  #adder_result=convAdd(convcphers,0,rownum*colnum)
  ## Unpack scalar
  begin = time.time()
  layer_output=unpack_ciphertext(adder_result,colnum)
  #layer_output=conv_result
  end = time.time()
  #print(f"Total runtime of the unpack program is {int(end - begin)} second") 
  ## encryoted relu
  #if(layer.lower() !='last'):
   # layer_output=encrypted_relu(layer_output)
  #print("The o/p of the Sample 3x3 Conv layer is")
  #convop=scalarDecrypt(layer_output)
  #Lets try enc-scalar-add here
  #conv_res=[]
  
  zerosum=aggregate(layer_output)
  zerosum1=unpack_ciphertext(zerosum,3)
  decsum=scalarDecrypt(zerosum1)
  #print("Outputing the Conv OUtput through encrypted allzero method is="+str(decsum))
  #print("The final o/p of fully encrypted Convolution Block="+str(decsum[2]))

  return zerosum1[2]

  decresult=scalarDecrypt(layer_output)
  #print("Intermediate ConvLayer o/p is")
  #print(decresult)

  ##Trying bitsliced encryotion
  op1=[]
  op2=[]
  op3=[]
  op1.append(decresult[0])
  op2.append(decresult[1])
  op3.append(decresult[2])
  encop1=bitsliced_encrypt(op1)
  encop2=bitsliced_encrypt(op2)
  encop3=bitsliced_encrypt(op3)

  res1=bitsliced_adder(encop1,encop2)
  bit_result=bitsliced_adder(res1,encop3)
  resultbits=bit_decrypt(bit_result)
  #print("Returning Final aggreagted conv result=")
  
  #print(twos_comp_val(resultbits,size,0),end="\t")
  

  return bit_result
  ##############Tring encrypted addition on layer_output
  #sum1=bitsliced_adder(list(layer_output[0]),list(layer_output[1]))
  #sum2=bitsliced_adder(list(layer_output[1]),sum1)
  #sumbits=bit_decrypt(sum2)
  #print("Final aggreagted conv result=")
  
  #print(twos_comp_val(sumbits,size,0),end="\t")


  ###Testing the encryoted sum/aggregation on ciphertexts


  #SSconvop=scalarDecrypt(cx)
  #SSprint(convop)
  #SSconv_scalar=[]
  #SSconv_scalar=scalarEncrypt(convop)
  #SSprint("Length of ecrypted scalar is"+str(len(conv_scalar)))
  #SSprint("Encrypted scalar looks like-")
  #SSfor i in range(0,len(conv_scalar)):
    #SSprint(conv_scalar[i].a)
    #SSprint("Outputing b part now-")
    #SSprint(conv_scalar[i].b)

  #SSconv_res=[]
  #SSconv_res=conv_scalar[0].a
  #SSfor ind in range(1,9):
     #SS conv_res=enc_scalar_add(conv_scalar[ind].a,conv_res)
  
  #SSprint("The convolution o/p is-"+scalarDecrypt(conv_res))
  #print("Encrypted conv op is")
  #print(layer_output)
  #print("Length of encrypted output is"+str(len(layer_output)))

  ###Aggregating the final convs###
  ciX=repack_ciphertext(layer_output)
  mul_result=enc_twos_complement(ciX,3)

  conv_final=unpack_ciphertext(mul_result,3)
  fin_conv=conv_final
  #print("The final individual convolution op is")
  #print(scalarDecrypt(fin_conv))
  return layer_output



def emptyconv(input,kern_dim,conv2d_dim):

 inpdim=28
 nullconv={}
 count=0
 for i in range(conv2d_dim):
    for j in range(conv2d_dim):
      startx=(i*inpdim)+j
      nullflag=0
      for xkern in range(kern_dim):
        for ykern in range(kern_dim):
          checkpos=startx+(xkern*inpdim)+ykern
          if input[checkpos]==0:
            continue
          else:
            nullflag=1
            break
      key=str(i)+"-"+str(j)
      if key in nullconv:
        nullconv[key].append(0)
      else:
        nullconv[key]=0
      if nullflag==1:
        nullconv[key]=1
        count=count+1
      else:
        nullconv[key]=0

 #print("Number of effective conv computation blocks="+str(count))


 return nullconv

def bitsliced_subtractor(ciX,ciY):
    result_sum=[]
    carry=vm.gate_constant([False])
    for i in range(size):
        temp1=vm.gate_xor(ca[i],cb[i]) # a XOR b
        result_sum.append(vm.gate_xor(temp1,carry)) # a XOR b XOR ci
        temp2=vm.gate_and(carry,temp1) # ci and (a XOR b)
        temp3=vm.gate_and(ca[i],cb[i]) # a AND b
        carry=vm.gate_or(temp3,temp2)
        
    
    if carry==[False]:
	    return 2
    else:
	    return 1

def FHEMux(op1,op2):
 
 size=32
 #size=16
 #size=12
 ciX=list(op1)
 ciY=list(twos_complement(op2,size))
 diff=bitsliced_subtractor(ciX,ciY)
 if diff==1:
   return op1
 else:
   return op2
 

def maxpool(pool_matrix,xoffset,yoffset):

 max1=FHEMux(pool_matrix[yoffset][xoffset],pool_matrix[yoffset][xoffset+1])
 max2=FHEMux(pool_matrix[yoffset+1][xoffset],pool_matrix[yoffset+1][xoffset+1])
 maxpool=FHEMux(max1,max2)
 maxval=twos_comp_val(list(maxpool))
 #print("The maxpool value is="+str(maxval))
 return maxval

 

def avgpool2D(pool_matrix,xoffset,yoffset):
 
  
  #print("AvgPool Memory Profiling")
  X1=[]
  X2=[]
  X3=[]
  X4=[]
  avgpool=[]
  
  X11=[]
  X22=[]
  sum1=[]
  sum2=[]
  sum3=[]

  avgpool.append(pool_matrix[yoffset][xoffset])
  avgpool.append(pool_matrix[yoffset][xoffset+1])
  avgpool.append(pool_matrix[yoffset+1][xoffset])
  avgpool.append(pool_matrix[yoffset+1][xoffset+1])
  #print("Length of X input is"+str(len(avgpool)))


  enczero=bit_encrypt(0)  

  ##X1.append(enczero)
  ##X1.append(enczero)
  ##X1.append(pool_matrix[yoffset][xoffset])
  #X1=X
  #X2=X
  #X3=X

  ##X2.append(enczero)
  ##X2.append(enczero)
  ##X2.append(pool_matrix[yoffset][xoffset+1])
  #temp2=X2[2]
  #X2[2]=X2[1]
  #X2[1]=temp2

  ##Swapping LSB with the MSB Operand##

  #temp3=X3[2]
  #X3[2]=X3[0]
  #X3[0]=temp3

  ##X3.append(enczero)
  ##X3.append(enczero)
  ##X3.append(pool_matrix[yoffset+1][xoffset])

  ##X4.append(enczero)
  ##X4.append(enczero)
  ##X4.append(pool_matrix[yoffset+1][xoffset+1])

  #print("Size of individual subarrays="+str(len(X2)))
  allzeros=[]
  allzeros.append(0)
  allzeros.append(0)
  allzeros.append(1)
  #print("Contents and length of all zero array="+str(len(allzeros))+str(allzeros))
  ciX=bitsliced_encrypt(allzeros)
  #print("Contents and length of all zero array="+str(len(ciX))+str(ciX))
  X11=repack_ciphertext(avgpool)
  temp0=avgpool[3]
  avgpool[3]=avgpool[2]
  avgpool[2]=temp0
  X22=repack_ciphertext(avgpool)
  temp0=avgpool[3]
  avgpool[3]=avgpool[1]
  avgpool[1]=temp0
  X33=repack_ciphertext(avgpool)

  temp0=avgpool[3]
  avgpool[3]=avgpool[0]
  avgpool[0]=temp0
  X44=repack_ciphertext(avgpool)

  #op1=masklsb(X11,ciX)
  #op2=masklsb(X22,ciX)
  #op3=masklsb(X33,ciX)

  sum1=bitsliced_adder(X11,X22)
  sum2=bitsliced_adder(sum1,X33)
  sum3=bitsliced_adder(sum2,X44)
  #sum2[0]=enczero
  #sum2[1]=enczero
  return sum3

def convpoolout(pool_matrix,xoffset,yoffset):
 
 for i in range(2):
   for j in range(2):
     key=str(yoffset+i)+"-"+str(xoffset+j)
     y = ctx.decrypt(secret_key,pool_matrix[yoffset+i][xoffset+j])
     resultbits=twos_comp_val(np.flipud(np.array(y)),size,-1)
     #print("ConvMatrix["+str(key)+"]=")
     #print(resultbits)
     #print("Printing again---")
     #print(twos_complement(resultbits,size)) 



def avgPool(pool_matrix,convpool_dim):

 avgpool_dim=int(convpool_dim/2)
 #print("AVgpool Dimension="+str(avgpool_dim))
 avgpool_matrix=np.empty((avgpool_dim,avgpool_dim), dtype=object)
 stride=2
 for i in range(convpool_dim):
   for j in range(convpool_dim):
     mpool=avgpool2D(pool_matrix,j,i)
     poolsum=unpack_ciphertext(mpool,4)
     decavgpool=scalarDecrypt(poolsum)
  #   print("The aggregated ouput of the Poolsum of 2x2 Avgpool Block="+str(decavgpool[3]))
     size=32
     #size=16
     #size=12
     k=0
     for k in range(size-2):                   #Providing 2-bit Right Shifts to avgpool ciphertexts#
       poolsum[3].a[k]=poolsum[3].a[(k+2)]
       poolsum[3].b[k]=poolsum[3].b[(k+2)]
     avgpool_matrix[i][j]=poolsum[3]
     y1 = ctx.decrypt(secret_key,poolsum[3])
     avgpoolbits=twos_comp_val(np.flipud(np.array(y1)),size,-1)    
   #  print("The final output of 2x2 AvgPool Matrix["+str(i)+"-"+str(j)+"]")
    # print(avgpoolbits)
     j=j+stride
   i=i+stride

 return avgpool_matrix

#fp2=open('INT8CNNConv2D_memory_profiler.log','a+')
#@profile(stream=fp2)
def conv2D(layer,input,kern_matrix,kern_dim,bias):
 print("Conv2D Operation Started with dimmensions=")
 #global packing_time
 #packing_time=0
 img_dim=28
 #conv2d_dim=img_dim-kern_dim+1
 conv2d_dim=6
 print(str(conv2d_dim))
 conv_matrix=np.empty((conv2d_dim,conv2d_dim), dtype=object)
 zerodict={}
 zerodict=emptyconv(input,kern_dim,conv2d_dim)

 avgpool_dim=int(conv2d_dim/2)
 #print("AVgpool Dimension="+str(avgpool_dim))
 avgpool_matrix=np.empty((avgpool_dim,avgpool_dim), dtype=object)
 ##Defining conv2D computation block
 
 convstart=time.time()
 conv2dstart=time.time()
 count=0
 for i in range(conv2d_dim):
   xoffset=0
   yoffset=i
   convrowout=[]
   convrowout=convMulAcc('first',test_samples[0],kern_weights,kern_dim,enc_params_1,xoffset,yoffset)
   for j in range(conv2d_dim):
     print("Currently at Conv Matrix i="+str(i)+" j="+str(j))
     #xoffset=j
     #yoffset=i
     key=str(i)+"-"+str(j)
     #if zerodict[key]==1: 
     count+=1
     #bitresult=convLayer('first',test_samples[0],kern_weights,kern_dim,enc_params_1,xoffset,yoffset)
     conv_matrix[i][j]=convrowout[j]
       
 print("Soumik-the convolution block is done now")    
 print("Time spent in packing/repacking operations ="+str(packing_time))

 
 
 convend=time.time()
 print(f"Total runtime of only the Conv2D layer is {int(convend - convstart)} second")

 ##Print convolution output

 avgpoolstart=time.time()
 i=0
 j=0
 for i in range(conv2d_dim-1):
   for j in range(conv2d_dim-1):
     print("Inside Conv Loop i="+str(i)+" and j="+str(j))
     key=str(i)+"-"+str(j)
     validflag=0
     avgi=int(i/2)
     avgj=int(j/2)
     if i%2==0 and j%2==0:
      validflag=1
     if zerodict[key]==0:    #####Using Same Block for both 0conv and non-zero Conv Layers#### 
      mpool=avgpool2D(conv_matrix,j,i)
      poolsum=unpack_ciphertext(mpool,4)
      decavgpool=scalarDecrypt(poolsum)
      print("The aggregated ouput of the Poolsum of 2x2 Avgpool Block="+str(decavgpool[3]))
      size=32
      #size=16
      #size=12
      k=0
      for k in range(size-2):                   #Providing 2-bit Right Shifts to avgpool ciphertexts#
        poolsum[3].a[k]=poolsum[3].a[(k+2)]
        poolsum[3].b[k]=poolsum[3].b[(k+2)]
      y1 = ctx.decrypt(secret_key,poolsum[3])
      avgpoolbits=twos_comp_val(np.flipud(np.array(y1)),size,-1)    
      print("The final output of 2x2 AvgPool Layer=")
      print(avgpoolbits)
      if validflag==1:
        print("Populating indices "+str(avgi)+" and "+str(avgj))
        avgpool_matrix[avgi][avgj]=poolsum[3] 

      ###Now will continue in next Block Conv2d###

      continue
      #resultbits=bit_decrypt(conv_matrix[i][j])
      decresult=[0.0,0.0,0.0]
      #print("Intermediate ConvLayer o/p is")
      #print(decresult)

      ##Trying bitsliced encryotion
      op1=[]
      op2=[]
      op3=[]
      op1.append(decresult[0])
      op2.append(decresult[1])
      op3.append(decresult[2])
      encop1=bitsliced_encrypt(op1)
      encop2=bitsliced_encrypt(op2)
      encop3=bitsliced_encrypt(op3)

      res1=bitsliced_adder(encop1,encop2)
      bit_result=bitsliced_adder(res1,encop3)
      conv_matrix[i][j]=bit_result
      resultbits=bit_decrypt(conv_matrix[i][j])
      size=32
      #size=16
      #size=12
      #print(twos_comp_val(resultbits,size,0))
      if validflag==1:
       avgpool_matrix[avgi][avgj]=conv_matrix[i][j]
     else:
      #resultbits=ctx.decrypt(secret_key, conv_matrix[i][j])
      convpoolout(conv_matrix,j,i)
      y = ctx.decrypt(secret_key,conv_matrix[i][j])
      size=32
      #size=16
      #size=12
      resultbits=twos_comp_val(np.flipud(np.array(y)),size,-1)
      print("ConvMatrix["+str(key)+"]=")
      print(resultbits)
      print("Printing again---")
      print(twos_complement(resultbits,size))
      mpool=avgpool2D(conv_matrix,j,i)
      poolsum=unpack_ciphertext(mpool,4)
      decavgpool=scalarDecrypt(poolsum)
      print("The aggregated ouput of the Poolsum of 2x2 Avgpool Block="+str(decavgpool[3]))
      size=32
      #size=16
      #size=12
      k=0
      for k in range(size-2):                   #Providing 2-bit Right Shifts to avgpool ciphertexts#
        poolsum[3].a[k]=poolsum[3].a[(k+2)]
        poolsum[3].b[k]=poolsum[3].b[(k+2)]
      y1 = ctx.decrypt(secret_key,poolsum[3])
      avgpoolbits=twos_comp_val(np.flipud(np.array(y1)),size,-1)    
      print("The final output of 2x2 AvgPool Layer=")
      print(avgpoolbits)
      if validflag==1:
       avgpool_matrix[avgi][avgj]=poolsum[3]
      #print(twos_comp_val(list(resultbits),size,0))
      #print(twos_complement(resultbits,size))

 #print("Hey Soumik---I am now done with populating the AvgPool Matrix ")
 avgpoolend=time.time()
 #print(f"Total runtime of the AvgPool layer is {int(avgpoolend - avgpoolstart)} second")
 #print(f"Total runtime of the Conv2D layer is {int(convend - convstart)} second")
 
 conv2dend=time.time()
 #print(f"Total runtime of the (Conv2D+AvgPool layer is {int(conv2dend - conv2dstart)} second")
 for i in range(avgpool_dim):
   for j in range(avgpool_dim):
     avgpool1 = ctx.decrypt(secret_key,avgpool_matrix[i][j])
     size=32
     #size=16
     #size=12
     avgpoolbits=twos_comp_val(np.flipud(np.array(avgpool1)),size,-1)    
  #   print("AvgPool Matrix=["+str(i)+"]["+str(j)+"]=")
   #  print(avgpoolbits)
     size=32
     #print(twos_comp_val(resultbits,size,0))
 #avgpoolresult=avgPool(conv_matrix,conv2d_dim-1)
 #print("Soumik---now I have outputted the 2x2 AvgPool computed Matrix")    

 ###Outputing the flatten layer###
 flatten_dim=avgpool_dim*avgpool_dim
 #print("Flatten-Layer Dimension="+str(flatten_dim))
 flatten_matrix=np.empty((flatten_dim), dtype=object)
 flattenstart=time.time()
 for i in range(avgpool_dim):
   for j in range(avgpool_dim):
     ind=i*avgpool_dim+j
     flatten_matrix[ind]=avgpool_matrix[i][j]
     #print("flatten_matrix["+str(i)+"]["+str(j)+"]=")
     flatten1=ctx.decrypt(secret_key,flatten_matrix[ind])
     flattenbits=twos_comp_val(np.flipud(np.array(flatten1)),size,-1) 
     #print(flattenbits) 
 flattenend=time.time()
 #print(f"Total runtime of Flatten layer is {int(flattenend - flattenstart)} second")
     
 return flatten_matrix



#global packing_time
packing_time=0

print("Tracemalloc is switched off now:")

## context creation
ctx = nufhe.Context()
secret_key, cloud_key = ctx.make_key_pair()
#print("My cloudkey is--")
#print(cloud_key)
vm = ctx.make_virtual_machine(cloud_key)
#set bit size for operation
size = 32
#size=16
#size=12
print("Exectuing program with bit-size="+str(size)+" bits")
## MNIST data testing
begin0 = time.time()
test_samples = np.around(np.load("test_samples.npy") * 255)
test_labels = np.load("test_labels.npy")
x_adv = np.load(f"x_adv.npy")
num_params = len(os.listdir("params"))
#repack_time=0
#dense_layer_weights=np.load(f"dense_weights1.npy")

dense_layer_weights=np.array([[1,2,3,4,5,6,7,8,9,10],[-1,2,-3,4,5,-6,-7,8,9,10],[-1,0,-2,0,-3,-4,5,6,7,10],[0,-1,-2,-3,-4,-5,-6,-7,-8,10],[0,1,3,5,7,9,8,6,4,10],[-2,-4,4,5,-5,6,-6,9,-9,10],[2,3,4,5,6,7,8,9,0,10],[3,4,5,6,7,8,9,0,1,10],[4,5,6,7,8,9,0,1,2,10]])
#print("the scanned NN weights are as follows:")

#for k in range(9):
 # print(dense_layer_weights[0][k])
  
#print("# of Rows in weight_matrix="+str(len(dense_layer_weights)))

#print("# of columns in weight matrix="+str(len(dense_layer_weights[0])))


params = []
for i in range(num_params):
	params.append(np.loadtxt(f"params/p{i}.txt", delimiter=","))
#enc_sample = scalarEncrypt(test_samples[0])
#print("The 1st MNIST Image is")
#print(test_samples[0])
enc_params_1 = bitsliced_encrypt(params[1])
kern_weights=np.array([[1,2,3],[1,2,3],[1,2,3]], dtype='int32')
#kern_weights=np.array([[1,2,3],[9,4,5],[6,7,8]], dtype='int32')
begin = time.time()
#print("######## Convolution Block-Op on Raw Image is starting............")
params6_row=len(params[6])
params6_col=len(params[6][0])

#print("Original Input row/colnum are="+str(params6_row)+"---"+str(params6_col))
#tracemalloc.start()
flatten_out=conv2D('first',test_samples[0],kern_weights,3,enc_params_1)
#print("Max/Min Memory consumption by Conv2d func is-")
#print(tracemalloc.get_traced_memory())

#with open("memusage.txt","a+") as memu:
#	memu.write("Conv2D Memusage Stats")
#	memu.write(str()
#tracemalloc.stop()
params7=[
    -156,
    450,
    -130,
    -207,
    101,
    40,
    -66,
    232,
    -367,
    45
]

public_weight_matrix=np.empty((169,10), dtype=object)

for i in range(169):
  for j in range(10):
    public_weight_matrix[i][j]=random.randrange(-20, 20, 2)
    
#print("# of Rows in MNIST weight_matrix="+str(len(public_weight_matrix)))

#print("# of columns in MNIST weight matrix="+str(len(public_weight_matrix[0])))

enc_params_7=bitsliced_encrypt(params7)

#tracemalloc.start()
densestart=time.time()
layer_3_output = denseLayer('last',flatten_out,dense_layer_weights,enc_params_7)
denseend=time.time()
print(f"Total runtime of only Denselayer is {int(denseend - densestart)} second")
#print("Max/Min Memory consumption by DenseLayer func is-")
#print(tracemalloc.get_traced_memory())
#tracemalloc.stop()
#tracemalloc.start()
#layer_3_output = denseLayer('last',flatten_out,public_weight_matrix,enc_params_7)
#print("Max/Min Memory consumption by Denselayer func is-")
#print(tracemalloc.get_traced_memory())
#tracemalloc.stop()
end = time.time()
#print(f"Total runtime of the last layer is {int(end - begin)} second")
#print("Layer 3 output:",scalarDecrypt(layer_3_output))
result= scalarDecrypt(layer_3_output)
end0 = time.time()
print("Last layer output:",result)
print("Predicted digit",np.argmax(result))
print(f"Total runtime of the MNIST-CNN Arch is {int(end0 - begin0)} second")
print("Total time exhausted in repacking/bitsliced encryption=")
#print(str(repack_time))
#layer_0_output = bitsliced_adder(bitsliced_encrypt(np.matmul(test_samples[0], params[0])),enc_params_1)
#layer_0_output=unpack_ciphertext(layer_0_output,len(params[1])) ## unpack to result ciphertexts
#layer_0_output = encrypted_relu(layer_0_output)
#end = time.time()
#print(f"Total runtime of the first layer is {int(end - begin)} second")
#print("Layer 0 output:",scalarDecrypt(convout))
